<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Spaced Practice</title>
<style>
  :root{
    --bg:#f9fafb; --card:#fff; --accent:#2563eb; --muted:#6b7280; --ok:#16a34a;
    --shadow:0 8px 30px rgba(0,0,0,.08);
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
    background:var(--bg); color:#111827; min-height:100vh; display:flex; flex-direction:column;
  }
  header{
    width:100%; padding:12px 16px; position:sticky; top:0; background:linear-gradient(#ffffffcc,#ffffffcc);
    backdrop-filter: saturate(1.2) blur(6px); border-bottom:1px solid #e5e7eb; z-index:10;
  }
  .title { margin:0 0 6px 0; font-weight:600; font-size:18px;}
  .keyword-bar{ display:flex; gap:4px 6px; flex-wrap:wrap; align-items:center; margin-top: 2px; }
  .pill{
    font-size:10px; font-weight: 500; line-height:1.1; padding:3px 7px; border-radius:8px; border:1px solid #d1d5db;
    background:#fff; color:#374151; cursor:pointer; user-select:none; 
    white-space: nowrap; transition: background 0.1s, border-color 0.1s;
  }
  .pill:hover {
    background: #f3f4f6;
  }
  .pill.active{ border-color:var(--accent); color:#fff; background:var(--accent) }
  .pill.clear{ background:#f3f4f6; color:#374151; border-color:#e5e7eb; font-style: italic; }

  main{
    width:100%; max-width:1200px; margin:0 auto; padding:16px; display:grid; gap:20px;
  }
  /* 2-column on non-mobile */
  @media (min-width: 900px){
    main { grid-template-columns: 2fr 1fr; align-items:start }
  }

  /* Card + flip */
  .card-zone{ display:flex; flex-direction:column; align-items:center; gap:16px }
  .card-wrapper{
    width:100%; max-width:820px; aspect-ratio: 16 / 10; /* landscape-ish */
    perspective: 1200px; margin:0 auto;
     /* Fallback for older browsers */
  /*height: min(60vh, 520px); */
  }
  .card{ position:relative; width:100%; height:100%; }
  .card-inner{
    position:absolute; inset:0; transition: transform 0.6s; transform-style:preserve-3d; will-change:transform;
  }
  .card.flipped .card-inner{ transform: rotateY(180deg); }

  .face{
    position:absolute; inset:0; backface-visibility:hidden; border-radius:16px; background:var(--card);
    box-shadow: var(--shadow); display:flex; align-items:center; justify-content:center; padding:24px;
  }
  .front{ font-size:2rem; text-align:center }

/*.face.front { position: relative; }
 #skipFrontBtn {
    position: absolute; right: 12px; bottom: 12px;
    font-size: 12px; padding: 6px 10px; border-radius: 999px;
    border: 1px solid #e5e7eb; background:#fff; cursor:pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,.05);
    }
#skipFrontBtn:hover { border-color: #cbd5e1; }*/
    .deckRef {
        position: absolute;
        bottom: 6px;
        left: 10px;
        font-size: 11px;
        color: #9ca3af;          /* tailwind gray-400 */
        pointer-events: none;    /* no interference with clicks */
        user-select: none;
    }


  .back{
    transform: rotateY(180deg); background:#ecfdf5; color:#064e3b;
    display:flex; flex-direction:column; gap:12px; padding:20px;
  }
  .answer-text{ font-size:1.8rem; text-align:center; flex:1; display:flex; align-items:center; justify-content:center; }

  .controls{
    display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap;
  }
  button{
    appearance:none; border:none; border-radius:10px; padding:10px 14px; cursor:pointer; font-size:16px;
    box-shadow: var(--shadow); background:#fff; border:1px solid #e5e7eb;
  }
  button.primary{ background:var(--accent); color:white; border-color:transparent }
  button.ghost{ background:transparent; border:1px dashed #cbd5e1; box-shadow:none }
  button.good{ background:#eafff1; color:#065f46; border-color:#bbf7d0 }

  /* Stats panel */
  .stats{
    background:#fff; border:1px solid #e5e7eb; border-radius:16px; padding:16px; box-shadow: var(--shadow);
    display:flex; flex-direction:column; gap:14px; position:sticky; top:76px;
  }
  .stat-row{ display:flex; justify-content:space-between; font-size:14px; color:#111827 }
  .stat-row .muted{ color:var(--muted) }
  .meter{
    height:10px; width:100%; background:#f3f4f6; border-radius:999px; overflow:hidden;
  }
  .meter > span{
    display:block; height:100%; background:linear-gradient(90deg, #34d399, #10b981); width:0%;
  }
  .small{ font-size:12px; color:var(--muted) }
  .decklist{ font-size:12px; color:#374151 }
</style>
</head>
<body>
  <header>
    <div class="title" id="pageTitle">Flashcards</div>
    <div class="keyword-bar" id="keywordBar">
      <!-- keyword pills injected here -->
    </div>
  </header>

  <main>
    <section class="card-zone">
      <div class="card-wrapper">
        <div class="card" id="card">
          <div class="card-inner" id="cardInner">
            <div class="face front" id="cardFront">
                <!--<button class="pill no-flip" id="skipFrontBtn" title="Skip this card">Skip</button>-->
                <div id="qText" class="qtext"></div>
                <div class="deckRef" id="deckRefFront"></div>
            </div>
            <div class="face back" id="cardBack">
              <div class="answer-text" id="answerText"></div>
              <div class="deckRef" id="deckRefBack"></div>
              <div class="controls">
                <button class="good no-flip" id="gotItBtn">‚úÖ Got it</button>
                <!--<button class="ghost no-flip" id="skipBtn">Skip</button>-->
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="controls">
        <button class="primary" id="flipBtn">Flip</button>
        <button id="resetBtn">üîÅ Reset</button>
        <button id="skipBtn">Skip</button>
      </div>
    </section>

    <aside class="stats">
      <div class="stat-row"><span>Total in active set</span><strong id="statTotal">0</strong></div>
      <div class="stat-row"><span>Done (‚úÖ)</span><strong id="statDone">0</strong></div>
      <div class="meter" aria-label="progress"><span id="meterBar"></span></div>
      <div class="stat-row small">
        <span class="muted">Remaining</span><span id="statRemain">0</span>
      </div>
      <hr/>
      <div class="small">Active filter: <strong id="statFilter">None</strong></div>
      <div class="small">Decks: <span class="decklist" id="statDecks"></span></div>
    </aside>
  </main>

  <!-- 1) bring in the manifest first -->
  <script src="manifest.js"></script>

  <script>
  // ====== URL params ======
  const params = new URLSearchParams(location.search);
  const decksParam = params.get('decks');          // comma-separated list, else all
  const tagParam   = params.get('tag');            // single tag filter (optional)
  const basePath   = params.get('base') || '';     // optional: e.g., "decks/"

  // ====== Deck capture shim (no changes to your deck files needed) ======
  // Each deck file sets window.topicHeading and window.flashcardData.
  // We intercept after load, capture, then clear.
  const capturedDecks = []; // {name, heading, cards}
  function captureCurrentDeck(filename){
    if (!window.flashcardData || !Array.isArray(window.flashcardData)) return;
    capturedDecks.push({
      name: filename.replace(/\.js$/,''),
      heading: window.topicHeading || filename,
      cards: window.flashcardData.map(c => ({
        question: c.question ?? '',
        answer:   c.answer ?? '',
        tags:     Array.isArray(c.tags) ? c.tags : []
      }))
    });
    // cleanup for next file
    delete window.flashcardData;
    delete window.topicHeading;
  }

  // ====== Load manifest and then selected decks ======
  const manifest = Array.isArray(window.decks) ? window.decks.slice() : [];
  const toLoad = (() => {
    if (!decksParam) return manifest;
    const wanted = new Set(decksParam.split(',').map(s=>s.trim()).filter(Boolean));
    return manifest.filter(fn => wanted.has(fn.replace(/\.js$/,'')));
  })();

  // Fall back if manifest missing:
  if (!toLoad.length && manifest.length){
    toLoad.push(...manifest);
  }

  // Helper to load one <script> and await onload
  function loadScript(src){
    return new Promise((resolve,reject)=>{
      const s = document.createElement('script');
      s.src = src;
      s.async = true;
      s.onload = ()=> resolve();
      s.onerror = ()=> reject(new Error('Failed to load '+src));
      document.head.appendChild(s);
    });
  }

  (async function init(){
    // Load decks serially so our capture sees each file
    for (const file of toLoad){
      const full = basePath ? `${basePath.replace(/\/?$/,'/')}${file}` : file;
      await loadScript(full);
      captureCurrentDeck(file);
    }

    // Merge active cards subject to tag filter
    const activeDecks = capturedDecks.slice();
    const activeCards = [];
    activeDecks.forEach(d => activeCards.push(...d.cards.map(c => ({...c, _deck:d.name}))));

    const allTags = [...new Set(activeCards.flatMap(c => c.tags))].sort((a,b)=>a.localeCompare(b));
    const keywordBar = document.getElementById('keywordBar');

    // Build tag pills
    let activeTag = tagParam || null;
    function renderPills(){
      keywordBar.innerHTML = '';
      if (activeTag){
        const clear = document.createElement('span');
        clear.className = 'pill clear';
        clear.textContent = 'Clear filter';
        clear.onclick = ()=>{ activeTag=null; applyFilter(); renderPills(); };
        keywordBar.appendChild(clear);
      }
      allTags.forEach(tag=>{
        const el = document.createElement('span');
        el.className = 'pill' + (activeTag===tag ? ' active':'');
        el.textContent = tag;
        el.onclick = ()=>{
          activeTag = (activeTag === tag) ? null : tag;
          applyFilter(); renderPills();
        };
        keywordBar.appendChild(el);
      });
    }

    // Heading
    const pageTitle = document.getElementById('pageTitle');
    if (activeDecks.length === 1) pageTitle.textContent = activeDecks[0].heading || 'Flashcards';
    else pageTitle.textContent = 'Flashcards';

    // Stats deck list
    document.getElementById('statDecks').textContent = activeDecks.map(d=>d.name).join(', ') || '‚Äî';

    // Card engine state
    let pool = activeCards.slice();       // filtered pool
    let used = new Set();                 // indices (within pool) marked ‚úÖ
    let currentIndex = null;

    // DOM handles
    const cardEl     = document.getElementById('card');
    const frontEl    = document.getElementById('cardFront');
    const backEl     = document.getElementById('cardBack');
    const ansEl      = document.getElementById('answerText');
    const flipBtn    = document.getElementById('flipBtn');
    const gotItBtn   = document.getElementById('gotItBtn');
    const skipBtn    = document.getElementById('skipBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const deckRefFront = document.getElementById('deckRefFront');
    const qText = document.getElementById('qText');
    //const deckRefBack  = document.getElementById('deckRefBack');

    // Stats DOM
    const statTotal  = document.getElementById('statTotal');
    const statDone   = document.getElementById('statDone');
    const statRemain = document.getElementById('statRemain');
    const meterBar   = document.getElementById('meterBar');
    const statFilter = document.getElementById('statFilter');

    function updateStats(){
      const total = pool.length;
      const done  = used.size;
      const remain= Math.max(0,total - done);
      statTotal.textContent = total;
      statDone.textContent  = done;
      statRemain.textContent= remain;
      meterBar.style.width  = total ? ((done/total)*100).toFixed(2)+'%' : '0%';
      statFilter.textContent = activeTag || 'None';
    }

    function applyFilter(){
      used.clear();
      if (activeTag){
        pool = activeCards.filter(c=>c.tags.includes(activeTag));
      } else {
        pool = activeCards.slice();
      }
      if (!pool.length){
        qText.textContent = 'No cards match this filter.';
        ansEl.textContent = '';
      }
      updateStats();
      nextCard(true);
    }

    function nextCard(force=false){
      // snap back to front
      cardEl.classList.remove('flipped');

      if (!pool.length){
        qText.textContent = 'No cards to show.';
        ansEl.textContent = '';
        return;
      }
      // If all used -> congrats screen
      if (used.size === pool.length){
        qText.textContent = "üéâ You've completed all cards in this set!";
        ansEl.textContent = "Tap Reset to start over or pick another keyword.";
        return;
      }
      // choose from remaining
      const remainingIdx = pool
        .map((_,i)=>i)
        .filter(i=>!used.has(i));
      currentIndex = remainingIdx[Math.floor(Math.random()*remainingIdx.length)];
      qText.textContent = pool[currentIndex].question || '‚Äî';
      ansEl.textContent   = pool[currentIndex].answer   || '‚Äî';

        // show deck name (from our earlier capture)
        //console.log(pool[currentIndex]._deck);
        const ref = pool[currentIndex]._deck ? `Deck: ${pool[currentIndex]._deck}` : 'where did this come from';
        deckRefFront.textContent = ref;
        deckRefBack.textContent  = ref;
    }

    // Interactions
    function flip(){ cardEl.classList.toggle('flipped'); }
    flipBtn.onclick = flip;
    //cardEl.addEventListener('click', (e)=>{
      // avoid double triggering when pressing buttons on the back
      //if (e.target === gotItBtn || e.target === skipBtn) return; //changed to line below
    //  if (e.target.closest('.no-flip')) return;
    //  flip();
    //});
    cardEl.addEventListener('click', (e) => {
  // ignore clicks on control buttons
  if (e.target.closest('.no-flip') || e.target.closest('button')) return;

  if (cardEl.classList.contains('flipped')) {
    // if already on the back, advance to next card
    cardEl.classList.remove('flipped');
    nextCard();
  } else {
    // if on the front, flip to show the answer
    cardEl.classList.add('flipped');
  }
});

    gotItBtn.onclick = ()=>{
      if (currentIndex==null) return;
      used.add(currentIndex);
      updateStats();
      // brief delay to let user register the press
      setTimeout(()=>{ cardEl.classList.remove('flipped'); nextCard(); }, 200);
    };

    skipBtn.onclick = ()=>{
      // do not mark used; just move on
      setTimeout(()=>{ cardEl.classList.remove('flipped'); nextCard(); }, 100);
    };

    //const skipFrontBtn = document.getElementById('skipFrontBtn');
    //    skipFrontBtn.onclick = (e) => { 
    //    e.stopPropagation(); // don‚Äôt bubble to card click
    //    nextCard(true);
    //};


    resetBtn.onclick = ()=>{
      used.clear();
      updateStats();
      nextCard(true);
    };

    // Initial render
    renderPills();
    applyFilter(); // applies tagParam if present
  })().catch(err=>{
    document.getElementById('cardFront').textContent = 'Load error: ' + err.message;
  });
  </script>
</body>
</html>
